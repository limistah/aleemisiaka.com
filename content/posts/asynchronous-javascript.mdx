---
title: Asynchronous Javascript
date: 2020-02-05
tags: [JS]
---

In computation systems, names like concurrent, sequential, parallel, serial, synchronous, asynchronous, non-blocking, shared state, message passing and likes, these names stand as a forbearer for the actual task that actually happens in a system.

While all of above techniques have their use cases, in the world of JavaScript, asynchronous and synchronous programming never leave the tongues of its programmers.

In his [__Concurrency glossary__](https://slikts.github.io/concurrency-glossary/?id=asynchronous-vs-synchronous-non-blocking-concurrent-vs-blocking-sequential), **Author** wrote about asynchronous, and said:

> Asynchrony means "not happening at the same time", and asynchronous message passing is a communication model that does not require the sending and receiving to be synchronized, meaning that the sender isn't blocked until the receiver is ready.

It might not be clear still, we will go into a later detail about this with a real life example. (_Don't tell anyone, life is mostly asynchronous_).

While languages like Java, C#, C++ etc runs their computation on the main thread, and could _spawn_ out a new thread to run another set of instructions which are in parallel to the main thread and could communicate with it, JavaScript in its uniquenes does not support that model of computation.

In JavaScript, all its computations and instructions are run in a [sequence](https://slikts.github.io/concurrency-glossary/?id=concurrent-order-independent-vs-sequential) (i.e one after another) in a single thread. This means that for instructions ranging from A, B, C, ... to E to be executed, A would be executed firstly and when done, B is then executed, then C, then D, then E which sees the program to its end.

![https://www.youtube.com/watch?v=2ZH_1d8TYVg](../assets/maxresdefault.jpg)


Still, with the _single threaded_ nature of JavaScript, there is a unique feature that makes it outstanding, it is its **non blocking I/O model**. I/O(Input/Output) counld be in any form, like fetching of data over the internet, getting a file from the filesystem and likes, all of these processes does not block the main thread from continuing its execution.



### A real life case study

___

> In high school, when students are given an assignment, they are required to submit it. Once they submit the assignment to the teacher, they are expected to wait until they are returned back to them already marked/graded.

> While they had submitted the assignments and were waiting for the results, they could do other things like reading, attend classes, play games and joke with friends.

> Once the teacher is done marking, the students are notified, and they would go to the teacher to pick them up, completing the process.

___

In this scenario, the students have done a task asynchronously. While the teacher could only do one thing at a time, they have asked the teacher to teach them and still mark their assignments.

It is clear that he could not complete both of them at the same time, so they would have to wait, but, set a trigger (through the class rep/governor) that made them to know that the assignments are ready and the results are out.

The notification could help the students to determine what next to do, either to proceed with putting their books into their bags or doing the corrections or learning from other classmates. (__whatever is next__)

That is what happens in asynchronous programming.

### Asynchrony in JavaScript

While the language comes with support for asynchronous programming, there was no inclusion of an official model to write an asynchronous program until programmers started inventing their own models.

In the modern JavaScript engine, there is an added support for writing asynchronous codes. We would be exploring these options and their demerits, and I would conclude with why I think that Async/Await is a great feature to understand. Let's hit the engine start knob.

### Callbacks

For seasoned developers, this might seem like unveiling a nightmare following their experiences with callback hell. But, callback is not that bad.

Callback is a function passed to a function call, the function would be executed when the called function determines. A basic example is what `setTimeout`, `setInterval` are doing. Once they are called, they take the function and execute it at the passed time in their second argument.

```js
setTimeout(() => console.log("This is a callback 1 sec. setTimeout test"), 1000);
setInterval(() => console.log("This is a callback 1 sec. setInterval test"), 1000);
```

The two function calls above receives a callback as their first argument, and execute it once they reach the time (1sec) in their second argument. They will never obstruct the main thread from continuing executing other functions, instead a trigger would be 





### Good Ol days of AJAX

It might be so uncommon to the modern developers what this means right in the browser with the myriads of NPM libraries that make this happen in a few lines of code, also, the inclusion of the _fetch_ API to the modern JavaScript engines.

Prior to the days of EcmaScript 6, while developers still really dislike working with JavaScript (_which is unavoidable, though_ ðŸ˜„), requests could be made over the internet through a feature of JavaScript called **Asynchronous JavaScript and XML**, popularly known as **AJAX**.

This AJAX feature was invented by Microsoft 